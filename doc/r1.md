#### 设置Libevent库

---

Libevent有一些全局的设置共享给所有的程序。他影响整个库。你必须在使用Libevent任一库之前来设置这些变量，否则会导致Libevent状态的不一致。

##### Libevnet的日志消息

---

Libevent可以记录内部的错误和警告。如果编译添加了对日志记录的支持，你也可以记录调试信息。这些信息默认的被输出了标准错误输出。你可以提供自己的日志记录函数来覆盖原来的日志记录的方式。

###### 接口

    #define EVENT_LOG_DEBUG     0
    #define EVENT_LOG_MSG       1
    #define EVENT_LOG_WARN      2
    #define EVENT_LOG_ERR       3


    /* Deprecated: see note at the end of this section */
    #define _EVENT_LOG_DEBUG    EVENT_LOG_DEBUG
    #define _EVENT_LOG_MSG      EVENT_LOG_MSG
    #define _EVENT_LOG_WARN     EVENT_LOG_WARN
    #define _EVENT_LOG_ERR      EVENT_LOG_ERR

    typedef void (*event_log_cb)(int severity, const char *msg);

    void event_set_log_callback(event_log_cb cb);

为了覆盖原来的日志记录函数，首先你要编写一个event_log_cb的函数，然后将其作为参数传给event_set_log_callback()。当Libevent想要记录信息是，它将会调用你提供的函数去记录。你可以通过调用event_set_log_callback()用NULL作为参数来设置使用原来的默认的日志记录方式。

###### 示例（r1_01.c）

	#include <event2/event.h>
    #include <stdio.h>

    static void discard_cb(int severity, const char *msg)
    {
        /* This callback does nothing */
    }

    static FILE *logfile = NULL;
    static void write_to_file_cb(int severity, const char *msg)
    {
        const char *s;
        if(!logfile){
            return;
        }

        switch(severity){
            case _EVENT_LOG_DEBUG:  s = "debug";    break;
            case _EVENT_LOG_MSG:    s = "msg";      break;
            case _EVENT_LOG_WARN:   s = "warn";     break;
            case _EVENT_LOG_ERR:    s = "err";      break;
            default:                s = "?";        break;  /* never reached */ 
        }
        fprintf(logfile, "[%s] %s\n", s, msg);
    }

    /* Turn off all logging from Libevent */
    void suppress_logging(void)
    {
        event_set_log_callback(discard_cb);
    }

    /* Recirect all Libevent log messages to the C stdio file 'f'. */
    void set_logfile(FILE *f)
    {
        logfile = f;
        event_set_log_callback(write_to_file_cb);
    }


###### 注意

使用程序猿自己提供的event_log_cb函数是不安全的。例如：如果你想写一个日志记录函数使用bufferevnets将信息发送到网络socket，可能会遇到奇怪的难以排除的bug。这个限制将会在将来的版本中的从一些函数中移除。

###### 接口（re_snip_02.c）

    #define EVENT_DBG_NONE  0
    #define EVENT_DBG_ALL   0xffffffffu

    void event_enable_debug_logging(ev_uint32_t which);

调试信息在大多数情况下是冗余的没有多大用处的。调用event_enable_debug_logging()用EVENT_DBG_NONE参数得到默认的设置，调用他用EVENT_DBG_ALL打开所有支持的调试信息。更多比较好的选项将会在将来的版本中被支持。

这些函数在<event2/event.h>中声明。除了event_enable_debug_logging()在Libevent2.1.1-alpha版本中首次出现外，其他的都在Libevent1.0c中首次出现。

###### 兼容性注意

在Libevent2.0.19-stable版本之前，EVENT_LOG_*宏被定义为以下划线开头，例如：_EVENT_LOG_DEBUG, _EVENT_LOG_MSG, _EVENT_LOG_WARN和_EVENT_LOG_ERR。这些先前的宏是弃用的，你只应该在为了向前兼容Libevent2.0.18-stable和之前的版本时使用。他们将会在将来的版本中被移除。

#### 处理致命的错误

当Libevent发现不可恢复的内部错误（像被损坏得数据结构），默认的处理方法是调用exit()或是abort()离开当前的工作进程。出现不可恢复的错误说明在你的程序中或是Libevent中出现了bug。

如果你想你的程序更加优雅的处理致命的错误你可以改变Libevent默认的处理方式，Libevent将调用你提供的函数来替代退出。

###### Interface

	typedef void (*event_fatal_cb)(int err);
	void event_set_fatal_callback(event_fatal_cb cb);

为了使用上面功能，你首先要定义一个当发生致命的错误的时候可供Libevent调用的函数，然后将这个函数传给event_set_fatal_callback()。 在设置完成之后，如果发生了致命的错误，Libevent将会调用你提供的函数。

你的函数不应该将控制权返回给Libevent。如果这么做了可能会引发一些未知的错误，Libevent应该立即退出以避免程序down掉。一旦你提供的函数被调用，你不应该再调用Libevent其他的函数。

这些函数在<event2/event.h>中声明。首次出现在Libevent2.0.3-alpha版本中。


#### 内存管理

Libevent默认使用标准的C库内存管理函数从堆上分配内存。你也可以使用通过提供malloc,realloc和free函数来使用其他的内存管理。如果你有更高效的内存分配器让Libevent使用，或者是你有内置指示器的内存分配器想让Libevent查找内存泄露，你可以使用自己的内存管理。

###### Interface

	void event_set_mem_functions(void *(*malloc_fn)(size_t sz),
								void *(*realloc_fn)(void *ptr, size_t sz),
								void (*free_fn)(void *ptr));


下面有一个简单的示例，使用统计总共分配了多少内存的内存分配器来替换Libevent的内存分配器。在实际使用中，你可能为了防止在多线程中使用时出错而在这里添加锁。

###### Example (r1_snip_03.c)

    #include <event2/event.h>
    #include <sys/types.h>
    #include <stdlib.h>

    union alignment {
        size_t sz;
        void *ptr;
        double dbl;
    };

    #define ALIGNMENT sizeof(union alignment)

    #define OUTPTR(ptr) (((char *) ptr) + ALIGNMENT)
    #define INPTR(ptr) (((char *) ptr) - ALIGNMENT)

    static size_t total_allocated = 0;
    static void *replacement_malloc(size_t sz)
    {
        void *chunk = malloc(sz + ALIGNMENT);
        if(!chunk){
            return chunk;
        }

        total_allocated += sz;
        *(size_t *)chunk = sz;
        return OUTPTR(chunk);
    }

    static void *replacement_realloc(void *ptr, size_t sz)
    {
        size_t old_size = 0;
        if(ptr) {
            ptr = INPTR(ptr);
            old_size = *(size_t *)ptr;
        }

        ptr = realloc(ptr, sz + ALIGNMENT);
        if(!ptr){
            return NULL;
        }

        *(size_t *)ptr = sz;
        total_allocated = total_allocated - old_size + sz;
        return OUTPTR(ptr);
    }

    static void *replacement_free(void *ptr)
    {
        ptr = INPTR(ptr);
        total_allocated -=*(size_t *) ptr;
        free(ptr);
    }

###### 注意

- 替换内存管理函数将会影响所有的Libevent中调用malloc，resize, 或是free函数的函数。因此你得确定在你调用任何Libevent函数之前来替换这些函数。否则，Libevent就可能使用你的版本的free函数来释放由C标准版本malloc申请的空间。
- malloc和realloc函数要返回和标准C库同样校准(alignment)的内存地址 
- realloc函数要正确处理realloc(NULL, sz)。
- realloc函数要正确处理realloc(ptr, 0)。
- free函数不需要处理free(NULL)。
- malloc函数不需要处理malloc(0)。
- 如果你在多线程中使用Libevent，你要确保你替换的函数是线程安全的。
- Libevent将会使用你提供的函数分配内存返回给你。因此如果你使用自己的内存管理函数替换了原来的函数，想要释放Libevent中函数申请并返回的内存，你将不的不使用你替换的函数来释放他们。

event_set_mem_functions()函数在<event2/event.h>中声明。最早出现在Libevent 2.0.1-alpha版本中。

Libevent可以在编译的时候设置禁止使用event_set_mem_functions。如果设置了，然后在程序中使用event_set_mem_functions()将不能编译或是链接。在Libevent2.0.1-alpha以及以后的版本，你可以通过宏EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED来判断event_set_mem_functions()是否存在。

